
package gui;
import java.awt.*;
import java.awt.event.MouseEvent;
import java.util.HashSet;
import java.util.Set;
import model.Grid;
import model.Cell;
/**
 * This class represents the panel that will display the grid of cells and the 
 * @author Marian Luca/ phantomCat1
 */
public class GridPanel extends javax.swing.JPanel {

    /**
     * Creates new form GridPanel
     */
    public GridPanel() {
        initComponents();
        initPanel();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    private int cellSize = 10;
    private int offsetX = cellSize;
    private int offsetY = cellSize;
    private Grid grid;
    private Cell start;
    private Cell end;
    private Set<Cell> walls;
    
    private void initPanel() {
        this.grid = new Grid();
        this.start = null;
        this.end = null;
        walls = new HashSet<Cell>();
    }
    
    /*
    This method returns the source cell 
    */
    public Cell getStart() {
        return start;
    }
    
    /*
    This method is used to set the start cell of the path
    */
    public void setStart(Cell s) {
        this.start = s;
    }
    
    /*
    This method returns the source cell 
    */
    public Cell getEnd() {
        return end;
    }
    
     /*
    This method is used to set the start cell of the path
    */
    public void setEnd(Cell s) {
        this.end = s;
    }
    
    /*
    This method is used to add selected cells to the set of walls
    */
    public void setWalls(Cell cell) {
        walls.add(cell);
    }
    
    /*
    This method is used to add selected cells to the set of walls
    */
    public void removeWalls(Cell cell) {
        walls.remove(cell);
    }
    
    public void setCellSize(int size) {
        if (size <=30 && size >= 10) {
            this.cellSize = size;
            this.offsetX = size;
            this.offsetY = size;
        }
    }
    
    private void paintCell(Graphics g, Cell cell, int x, int y) {
       if (cell.isWall()) {
           g.setColor(Color.black);
       } else if (cell.isStart()) {
           g.setColor(Color.green);
       } else if (cell.isEnd()) {
           g.setColor(Color.red);
       } else {
           g.setColor(Color.white);
       }
       g.fillRect(x + 1, y + 1,
                    cellSize - 1, cellSize - 1);
    }
    
    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        final int width = 850;//this.cellSize*grid.getCols(); //this.getWidth();
        final int height = 530;//this.cellSize*grid.getRows(); //this.getHeight();
        g.setColor(Color.WHITE);
        g.fillRect(0, 0, WIDTH, HEIGHT);
        g.setColor(Color.BLACK);
        //draw horizontal separator lines
        for (int r = 0; r < grid.getRows();  r++) {
            final int y = r * cellSize;// + offsetY; these represent different ways i've played around with the graphics
            g.drawLine(0, y, width , y); //+offsetX
        }
        
        // draw all vertical separator lines
        for (int c = 0; c < grid.getCols();  c++) {
            final int x = c * cellSize;// + offsetX;
            g.drawLine(x, 0, x, height); //+offsetY
        }
        
        // draw cells
        for (int r = 0; r < grid.getRows();  r++) {
            final int y = (r ) * cellSize;// + offsetY;
            for (int c = 0; c < grid.getCols();  c++) {
                final int x = c * cellSize;// + offsetX;
                // x, y = coordinate of bottom-left corner
                final Cell cell = grid.getCell(r, c);
                paintCell(g, cell, x, y);
            }
        }
    }
    
    /**
     * This method returns the cell in grid upon a given mouse event
     * @param evt the mouse event
     * @return cell in grid at {@code evt} or {@code null} if non-existent
     */
    public Cell mouseToCell(final MouseEvent evt) {
        final int row = (evt.getY()) / cellSize;
        final int col = (evt.getX()) / cellSize;
        if (this.grid.getCell(row, col) != null) {
            return grid.getCell(row, col);
        } else {
            return null;
        }
    }
    
}
